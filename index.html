<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from src/site/markdown/index.md at 2024-03-04
 | Rendered using Apache Maven Fluido Skin 1.11.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>Immutable Collections for Java &#x2013; Immutable Collections For Java</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.11.1.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-1.11.1.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h1>JImmutable Collections</h1>
</div>
</div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2024-03-04<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 4.0.1</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Overview</li>
    <li class="active"><a><span class="none"></span>Introduction</a></li>
    <li><a href="LICENSE.html" title="License"><span class="none"></span>License</a></li>
    <li><a href="apidocs/org/javimmutable/collections/package-summary.html" title="API Docs"><span class="none"></span>API Docs</a></li>
    <li><a href="dependency-info.html" title="Dependency Info"><span class="none"></span>Dependency Info</a></li>
    <li><a href="http://central.sonatype.com/artifact/org.javimmutable/collections/overview" class="externalLink" title="Maven Page"><span class="none"></span>Maven Page</a></li>
   <li class="nav-header">Documentation</li>
    <li><a href="http://github.com/brianburton/java-immutable-collections/wiki/" class="externalLink" title="Introduction"><span class="none"></span>Introduction</a></li>
    <li><a href="http://github.com/brianburton/java-immutable-collections/wiki/Collections-Overview/" class="externalLink" title="Collections Overview"><span class="none"></span>Collections Overview</a></li>
    <li><a href="http://github.com/brianburton/java-immutable-collections/wiki/Factory-Methods/" class="externalLink" title="Creating Collections"><span class="none"></span>Creating Collections</a></li>
    <li><a href="http://github.com/brianburton/java-immutable-collections/wiki/List-Tutorial/" class="externalLink" title="List Tutorial"><span class="none"></span>List Tutorial</a></li>
    <li><a href="http://github.com/brianburton/java-immutable-collections/wiki/Map-Tutorial/" class="externalLink" title="Map Tutorial"><span class="none"></span>Map Tutorial</a></li>
    <li><a href="http://github.com/brianburton/java-immutable-collections/wiki/Array-Tutorial/" class="externalLink" title="Array Tutorial"><span class="none"></span>Array Tutorial</a></li>
    <li><a href="http://github.com/brianburton/java-immutable-collections/wiki/Streams-and-Lambdas/" class="externalLink" title="Streams and Lambdas"><span class="none"></span>Streams and Lambdas</a></li>
    <li><a href="http://github.com/brianburton/java-immutable-collections/wiki/Comparative-Performance/" class="externalLink" title="Comparative Performance"><span class="none"></span>Comparative Performance</a></li>
    <li><a href="http://github.com/brianburton/java-immutable-collections/wiki/Hash-Keys/" class="externalLink" title="Hash Keys"><span class="none"></span>Hash Keys</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<h1>Immutable Collections For Java</h1><section>
<h2><a name="Overview"></a>Overview</h2>
<p>The immutable collections for Java library (JImmutable Collections) is a bundle of high performance immutable
collections intended to replace or supplement the standard <code>java.util</code> collections. Functional replacements are provided
for each of the most commonly used collections:</p>
<table border="0" class="table table-striped">
<thead>

<tr class="a">
<th>Java Class</th>
<th>JImmutable Interface</th>
<th>Factory Methods</th></tr>
</thead><tbody>

<tr class="b">
<td align="left">ArrayDeque</td>
<td>IDeque</td>
<td><code>IDeques.of()</code>, <code>IDeques.allOf()</code></td></tr>
<tr class="a">
<td align="left">ArrayList</td>
<td>IList</td>
<td><code>ILists.of()</code>, <code>ILists.allOf()</code></td></tr>
<tr class="b">
<td align="left">LinkedList</td>
<td>IList</td>
<td><code>ILists.of()</code>, <code>ILists.allOf()</code></td></tr>
<tr class="a">
<td align="left">HashMap</td>
<td>IMap</td>
<td><code>IMaps.hashed()</code></td></tr>
<tr class="b">
<td align="left">TreeMap</td>
<td>IMap</td>
<td><code>IMaps.sorted()</code> <code>IMaps.sorted(Comparator)</code></td></tr>
<tr class="a">
<td align="left">LinkedHashMap</td>
<td>IMap</td>
<td><code>IMaps.ordered()</code></td></tr>
<tr class="b">
<td align="left">HashSet</td>
<td>ISet</td>
<td><code>ISets.hashed()</code></td></tr>
<tr class="a">
<td align="left">TreeSet</td>
<td>ISet</td>
<td><code>ISets.sorted()</code> <code>ISets.sorted(Comparator)</code></td></tr>
<tr class="b">
<td align="left">LinkedHashSet</td>
<td>ISet</td>
<td><code>ISets.ordered()</code></td></tr>
</tbody>
</table>
<p>There are also a number of highly useful collections with no equivalent in the standard Java library.</p>
<table border="0" class="table table-striped">
<thead>

<tr class="a">
<th>Description</th>
<th>JImmutable Interface</th>
<th>Factory Method</th></tr>
</thead><tbody>

<tr class="b">
<td align="left">Map of lists of items related by a key.</td>
<td>IListMap</td>
<td><code>IListMaps.hashed()</code> <code>IListMaps.sorted()</code>  <code>IListMaps.sorted(Comparator)</code>  <code>IListMaps.ordered()</code></td></tr>
<tr class="a">
<td align="left">Map of sets of items related by a key.</td>
<td>ISetMap</td>
<td><code>ISetMaps.hashed()</code> <code>ISetMaps.sorted()</code>  <code>ISetMaps.sorted(Comparator)</code>  <code>ISetMaps.ordered()</code></td></tr>
<tr class="b">
<td align="left">Set that tracks number of times any given element was added.</td>
<td>IMultiset</td>
<td><code>IMultisets.hashed()</code>  <code>IMultisets.sorted()</code> <code>IMultisets.sorted(Comparator)</code> <code>IMultisets.ordered()</code></td></tr>
<tr class="a">
<td align="left">Sparse array of elements indexed by an Integer.</td>
<td>IArray</td>
<td><code>IArrays.of()</code> <code>IArrays.allOf()</code></td></tr>
</tbody>
</table>
<p>The collections support these standard Java features:</p>
<ul>

<li>All are fully <code>Serializable</code> to facilitate storing to disk or sending over a network (i.e. in an Apache Spark
application)</li>
<li>All allow creation of Streams (parallel or sequential) over their contents. Maps support streams over their keys and
values separately or both at the same time.</li>
<li>All are <code>Iterable</code>. Maps support iterators over their keys and values separately or both at the same time.</li>
<li>Where appropriate they provide views that can be passed to code that requires a standard collection interface.  (
e.g. <code>IMap</code> has a <code>getMap()</code> method to create a view that implements <code>Map</code>)</li>
<li>Most provide collectors for use with Streams to create new collections in <code>collect()</code> method call. (see <code>ICollectors</code>)</li>
<li>Most provide efficient builder classes for constructing new collections in imperative fashion.</li>
</ul></section><section>
<h2><a name="Immutability.2FPersistence"></a>Immutability/Persistence</h2>
<p>The collections are all <a class="externalLink" href="https://en.wikipedia.org/wiki/Immutable_object">immutable</a>
and <a class="externalLink" href="https://en.wikipedia.org/wiki/Persistent_data_structure">persistent</a>. Any method that adds or removes an item in a
collection actually creates a new collection. The old and new collections share almost all of their structure in common
with only the minimum number of new objects needed to implement the change in the new version. The process of creating a
new collection from an old one is extremely fast.</p>
<p>Since the collections are immutable they can be safely shared throughout a program without the need for synchronization
or defensive copying. In fact structure sharing is a theme throughout the library. For example, you never actually
create an empty IList instance. The <code>ILists.of()</code> factory method always returns a single, shared, empty
list instance. The other factory methods work the same way.</p>
<p>The collections are still highly dynamic and fully support addition, deletion, and replacement of elements via efficient
creation of modified versions of themselves. This sets them apart from the static immutable collections in
the <a class="externalLink" href="https://github.com/google/guava">Guava</a> collections library.</p>
<p><b>Note:</b> Keep in mind that while the collections themselves are immutable the values you choose to store in them might
not be. Always <a class="externalLink" href="https://github.com/brianburton/java-immutable-collections/wiki/Hash-Keys">use immutable objects as keys</a>
and if you use mutable objects as values be aware that your code could mutate them between when you add them to a
collection and when you retrieve them later.</p></section><section>
<h2><a name="Dependencies"></a>Dependencies</h2>
<p>The library is designed to have no dependencies on other libraries, but it should interact well with others. Standard
java interfaces are used where appropriate.</p></section><section>
<h2><a name="Factory_Methods"></a>Factory Methods</h2>
<p>Static factory methods make it easy to create new collections. Here are various ways to
create the same basic list. Similar factory methods exist for the other collections.</p>

<div class="source"><pre class="prettyprint"><code>        List&lt;String&gt; sourceList = Arrays.asList(&quot;these&quot;, &quot;are&quot;, &quot;some&quot;, &quot;strings&quot;);
        IList&lt;String&gt; empty = ILists.of();
        IList&lt;String&gt; aList = empty
            .insert(&quot;these&quot;)
            .insert(&quot;are&quot;)
            .insert(&quot;some&quot;)
            .insert(&quot;strings&quot;);
        IList&lt;String&gt; literal = ILists.of(&quot;these&quot;, &quot;are&quot;, &quot;some&quot;, &quot;strings&quot;);
        IList&lt;String&gt; fromJavaList = ILists.allOf(sourceList);
        IList&lt;String&gt; fromBuilder = ILists.&lt;String&gt;builder()
            .add(&quot;these&quot;)
            .add(&quot;are&quot;)
            .addAll(&quot;some&quot;, &quot;strings&quot;)
            .build();
        assertThat(aList).isEqualTo(literal);
        assertThat(fromJavaList).isEqualTo(literal);
        assertThat(fromBuilder).isEqualTo(literal);
</code></pre></div></section><section>
<h2><a name="Iterators"></a>Iterators</h2>
<p>The collections are all <code>Iterable</code> so they can be used in standard <code>for</code> loops.</p>

<div class="source"><pre class="prettyprint"><code>        int eWordCount = 0;
        for (String word : fromBuilder) {
            if (word.contains(&quot;e&quot;)) {
                eWordCount += 1;
            }
        }
        assertThat(eWordCount).isEqualTo(3);
</code></pre></div></section><section>
<h2><a name="Streams_and_Collectors"></a>Streams and Collectors</h2>
<p>Streams can be used along with the provided collector methods to easily create new collections. For example this
function creates a list of the integer factors (other than 1) of an integer.</p>

<div class="source"><pre class="prettyprint"><code>    private IList&lt;Integer&gt; factorsOf(int number)
    {
        final int maxPossibleFactor = (int)Math.sqrt(number);
        return IntStream.range(2, maxPossibleFactor + 1).boxed()
            .filter(candidate -&gt; number % candidate == 0)
            .collect(ICollectors.toList());
    }
</code></pre></div>
<p>This code creates a lookup table of all the factors of the first 1000 integers into an <code>IMap</code>.</p>

<div class="source"><pre class="prettyprint"><code>        IMap&lt;Integer, IList&lt;Integer&gt;&gt; factorMap =
            IntStream.range(2, 100).boxed()
                .map(i -&gt; IMapEntry.of(i, factorsOf(i)))
                .collect(ICollectors.toMap());
</code></pre></div>
<p>This code shows how the lookup table could be used to get a list of the prime numbers in the map:</p>

<div class="source"><pre class="prettyprint"><code>        IList&lt;Integer&gt; primes = factorMap.stream()
            .filter(e -&gt; e.getValue().isEmpty())
            .map(e -&gt; e.getKey())
            .collect(ICollectors.toList());
        assertThat(primes)
            .isEqualTo(ILists.of(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 
                                 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97));
</code></pre></div></section><section>
<h2><a name="Iteration"></a>Iteration</h2>
<p>In addition to fully supporting Streams and Iterators the collections also provide their own iteration methods that
operate in a more functional style. For example the <code>forEach()</code> method takes a lambda and invokes it for each element of
the collection:</p>

<div class="source"><pre class="prettyprint"><code>        ISet&lt;Integer&gt; numbers = IntStream.range(1, 20).boxed().collect(ICollectors.toSet());
        numbers.forEach(i -&gt; System.out.println(i));
</code></pre></div>
<p>Methods are also provided to iterate over an entire collection to produce a new one by applying a predicate or
transformation. All of these operations can be done with Stream/map/filter/collect as well of course, but these
light-weight versions are faster when a single thread is sufficient for the job.</p>

<div class="source"><pre class="prettyprint"><code>        ISet&lt;Integer&gt; numbers = IntStream.range(1, 20).boxed().collect(ICollectors.toSet());
        ISet&lt;Integer&gt; changed = numbers.reject(i -&gt; i % 3 != 2);
        assertThat(changed).isEqualTo(ISets.hashed(2, 5, 8, 11, 14, 17));
        
        changed = numbers.select(i -&gt; i % 3 == 1);
        assertThat(changed).isEqualTo(ISets.hashed(1, 4, 7, 10, 13, 16, 19));

        IDeque&lt;Integer&gt; transformed = changed.stream().collect(ICollectors.toDeque());
        assertThat(transformed).isEqualTo(IDeques.of(1, 4, 7, 10, 13, 16, 19));
</code></pre></div></section><section>
<h2><a name="Slicing_and_Dicing_Lists"></a>Slicing and Dicing Lists</h2>
<p>Lists allow elements (and even whole lists) to be added or deleted at any index. They also support grabbing sub-lists
from anywhere within themselves. This example shows how various sub-lists can be extracted from a list and then inserted
into the middle of another.</p>

<div class="source"><pre class="prettyprint"><code>        IList&lt;Integer&gt; numbers = IntStream.range(1, 21).boxed().collect(ICollectors.toList());
        IList&lt;Integer&gt; changed = numbers.prefix(6);
        assertThat(changed).isEqualTo(ILists.of(1, 2, 3, 4, 5, 6));
        
        changed = numbers.suffix(16);
        assertThat(changed).isEqualTo(ILists.of(17, 18, 19, 20));
        
        changed = changed.insertAll(2, numbers.prefix(3).insertAllLast(numbers.middle(9, 12)));
        assertThat(changed).isEqualTo(ILists.of(17, 18, 1, 2, 3, 10, 11, 12, 19, 20));
</code></pre></div>
<p>Inserting entire lists will always reuse structure from both lists as much as possible. Likewise, removing sub-lists
from within a large list will produce a new list that shares most of its structure with the original list. This means
building a large list by successively appending other lists to it can be faster than inserting the individual values
into a builder.</p></section><section>
<h2><a name="Maps_of_Sets_and_Lists"></a>Maps of Sets and Lists</h2>
<p>The <code>ISetMap</code> makes it easy to index values or accumulate values related to a key. The <code>IListMap</code>
works similarly but accumulates lists of values by key so it can preserve the order in which they are added and track
duplicates.</p>
<p>The example below shows a trivial example of indexing a sequence of sentences by the words they contain.</p>

<div class="source"><pre class="prettyprint"><code>        IList&lt;String&gt; source = ILists.of(&quot;Now is our time.&quot;,
                                         &quot;Our moment has arrived.&quot;,
                                         &quot;Shall we embrace immutable collections?&quot;,
                                         &quot;Or tread in dangerous synchronized waters forever?&quot;);
        ISetMap&lt;String, String&gt; index = source
            .stream()
            .flatMap(line -&gt; Stream.of(line
                                           .toLowerCase()
                                           .replace(&quot;.&quot;, &quot;&quot;)
                                           .replace(&quot;?&quot;, &quot;&quot;)
                                           .split(&quot; &quot;))
                .map(word -&gt; MapEntry.entry(word, line)))
            .collect(ICollectors.toSetMap());
        assertThat(index.get(&quot;our&quot;)).isEqualTo(ISets.hashed(&quot;Now is our time.&quot;, &quot;Our moment has arrived.&quot;));
</code></pre></div>
<p>These classes offer a variety of methods for adding elements individually or in groups as well as iterating over all the
values for a given key as well as over the entire collection.</p>

<div class="source"><pre class="prettyprint"><code>        IListMap&lt;String, Integer&gt; index = IListMaps.&lt;String, Integer&gt;sorted()
            .insert(&quot;c&quot;, 2)
            .insert(&quot;a&quot;, 1)
            .insert(&quot;d&quot;, 640)
            .insert(&quot;b&quot;, 3)
            .insert(&quot;d&quot;, 512)
            .insertAll(&quot;a&quot;, ILists.of(-4, 40, 18)); // could be any Iterable not just list
        // keys are sorted in the map
        assertThat(ILists.allOf(index.keys())).isEqualTo(ILists.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));
        // values appear in the list in order they are added
        assertThat(index.getList(&quot;a&quot;)).isEqualTo(ILists.of(1, -4, 40, 18));
        assertThat(index.getList(&quot;d&quot;)).isEqualTo(ILists.of(640, 512));
        assertThat(index.getList(&quot;x&quot;)).isEqualTo(ILists.of());
</code></pre></div></section><section>
<h2><a name="ConcurrentModificationException"></a>ConcurrentModificationException</h2>
<p>Immutable collections never throw these. The example below is contrived, but it illustrates the problem of updating a
mutable collection while iterating over its contents. Since immutable collections are persistent you are always
modifying a different version of the collection, and the iterator doesn't become confused.</p>

<div class="source"><pre class="prettyprint"><code>        assertThatThrownBy(() -&gt; {
            Map&lt;Integer, Integer&gt; ints = IntStream.range(1, 11).boxed().collect(Collectors.toMap(i -&gt; i, i -&gt; i));
            for (Map.Entry&lt;Integer, Integer&gt; entry : ints.entrySet()) {
                ints.put(2 * entry.getKey(), 2 * entry.getValue());
            }
        }).isInstanceOf(ConcurrentModificationException.class);

        IMap&lt;Integer, Integer&gt; myMap = IntStream.range(1, 11).boxed().map(i -&gt; IMapEntry.of(i, i)).collect(ICollectors.toMap());
        for (IMapEntry&lt;Integer, Integer&gt; entry : myMap) {
            myMap = myMap.assign(2 * entry.getKey(), 2 * entry.getValue());
        }
        assertThat(ILists.allOf(myMap.keys())).isEqualTo(ILists.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16, 18, 20));
        assertThat(ILists.allOf(myMap.values())).isEqualTo(ILists.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16, 18, 20));
</code></pre></div>
<p>The static collector factory methods create collectors that add elements from the stream to an empty collection.
Instances of the collection classes also provide an instance method to create a collector based on that instance (rather
than an empty instance). This can be used with a Stream to add entries to the collection. The example below adds entries
to the map. Some keys update existing entries while others are new keys to be added to the collection.</p>

<div class="source"><pre class="prettyprint"><code>        myMap = IntStream.range(1, 11).boxed().map(i -&gt; IMapEntry.of(i, i)).collect(ICollectors.toMap());
        IMap&lt;Integer, Integer&gt; changed = myMap.stream()
            .map(entry -&gt; IMapEntry.of(5 + entry.getKey(), 10 + entry.getValue()))
            .collect(myMap.mapCollector());
        // 6-10 were updated, 11-15 were added
        assertThat(ILists.allOf(changed.keys())).isEqualTo(ILists.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15));
        assertThat(ILists.allOf(changed.values())).isEqualTo(ILists.of(1, 2, 3, 4, 5, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20));
        // original map is unchanged 
        assertThat(ILists.allOf(myMap.keys())).isEqualTo(ILists.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
</code></pre></div></section><section>
<h2><a name="Maybe_-_Handling_Optional_Values"></a>Maybe - Handling Optional Values</h2>
<p>The <code>Maybe</code> class, returned by <code>find()</code> methods in all collections, is similar to <code>Optional</code> but has several
advantages:</p>
<ul>

<li><code>Maybe</code> is serializable so you can use it as a field in <code>Serializable</code> objects if desired.</li>
<li><code>Maybe</code> offers more utility methods than <code>Optional</code>.</li>
<li><code>Maybe</code> supports null values (sometimes you just want null&#x2026;)</li>
</ul>
<p><code>Maybe</code> and <code>NotNull</code> can interoperate with one another. Calling <code>notNull()</code> on a <code>Maybe</code> returns a <code>NotNull</code> reflecting
the presence and nullity of a value in the <code>Maybe</code>. Similarly, calling <code>maybe()</code> on a <code>NotNull</code> returns a <code>Maybe</code>
reflecting the presence of a value in the <code>NotNull</code>. Note that this is not always a round trip.<br />
If <code>m</code> is a <code>Maybe</code> containing a null value calling <code>m.notNull().maybe()</code> will return an empty <code>Maybe</code>.</p></section><section>
<h2><a name="NotNull_-_Avoiding_null"></a>NotNull - Avoiding null</h2>
<p>The use of null has been controversial. The JImmutable collections are mostly indifferent to null. Nulls are not
permitted as keys to maps or values in sets. However, they can be stored as values in lists and maps. Maybes returned
by the <code>find()</code> method permit nulls as well.</p>
<p>There are many disadvantages to nulls though. In particular, they cannot be used in call chains. The <code>NotNull</code> class
provides an alternative to null that can be easily chained in a functional style.  <code>NotNull</code> is similar to <code>Maybe</code> but
does not allow nulls and provides more monadic functionality. It is meant to be used in sequences of method calls.</p>
<p>There are two possible states for a <code>NotNull</code> object:</p>
<ul>

<li><code>Empty</code> indicates no value is stored within the <code>NotNull</code>. The <code>unsafeGet</code> methods cannot be called on these objects
but all others can be called safely.</li>
<li><code>Full</code> indicates a non-null value is stored within the <code>NotNull</code>. All methods can be called on these objects.</li>
</ul>
<p>NotNull should be used when a value might not exist or might be null. For example as the result of a database query for
a single object. Once you have a NotNull value you can call the <code>map</code> method with a lambda that transforms the value
(if one exists). The transformed value can be of the same or another type. If your lambda returns another NotNull you
should use the <code>flatMap</code> method to &#x201c;unwrap&#x201d; the resulting value.</p>

<div class="source"><pre class="prettyprint"><code>// simplified class for illustration - normally you'd use getters
class Person
{
  final String emailAddress;
  final NotNull&lt;PhoneNumber&gt; homePhone;
  final NotNull&lt;PhoneNumber&gt; mobilePhone;
}

NotNull&lt;Person&gt; customer = customers.lookupCustomerByName(&quot;Jones&quot;, &quot;Patrick&quot;);
NotNull&lt;String&gt; email = customer.map(c -&gt; c.emailAddress);

// get the area code from the home phone number if we have one, &quot;&quot; otherwise
String areaCode = customer.flatMap(c -&gt; c.homePhone)
          .map(phone -&gt; phone.getAreaCode())
          .get(&quot;&quot;);

// another way to do the same - using match
areaCode = customer.flatMap(c -&gt; c.homePhone)
                   .match(&quot;&quot;, phone -&gt; phone.getAreaCode());
</code></pre></div>
<h1>Resources</h1></section><section>
<h2><a name="Wiki_Pages"></a>Wiki Pages</h2>
<p><a class="externalLink" href="https://github.com/brianburton/java-immutable-collections/wiki/JImmutables-Factory-Methods">JImmutables Factory Methods</a><br />
<a class="externalLink" href="https://github.com/brianburton/java-immutable-collections/wiki/Collections-Overview">Collections Overview</a><br />
<a class="externalLink" href="https://github.com/brianburton/java-immutable-collections/wiki/List-Tutorial">List Tutorial</a><br />
<a class="externalLink" href="https://github.com/brianburton/java-immutable-collections/wiki/Map-Tutorial">Map Tutorial</a><br />
<a class="externalLink" href="https://github.com/brianburton/java-immutable-collections/wiki/Array-Tutorial">Array Tutorial</a><br />
<a class="externalLink" href="https://github.com/brianburton/java-immutable-collections/wiki/Streams-and-Lambdas">Streams and Lambdas</a><br />
<a class="externalLink" href="https://github.com/brianburton/java-immutable-collections/wiki/Comparative-Performance">Comparative Performance</a><br />
<a class="externalLink" href="https://github.com/brianburton/java-immutable-collections/wiki/Hash-Keys">Hash Keys</a><br />
<a class="externalLink" href="http://brianburton.github.io/java-immutable-collections/apidocs/index.html">Project Javadoc</a><br />
<a class="externalLink" href="https://github.com/brianburton/javimmutable-jackson">Jackson Module for JSON Support</a></p></section><section>
<h2><a name="Project_Status"></a>Project Status</h2>
<p>All production releases undergo stress testing and pass all junit tests. Of course, you should evaluate the collections
for yourself and perform your own tests before deploying the collections to production systems.</p>
<p>All releases are uploaded to the <a class="externalLink" href="https://github.com/brianburton/java-immutable-collections/releases">releases section</a>
on GitHub and are also available via Maven
in <a class="externalLink" href="https://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.javimmutable%22%20AND%20a%3A%22javimmutable-collections%22">Maven Central</a>
. You can add JImmutable Collections to your Maven project by adding a dependency like this to your pom.xml. The maven
releases include source jars for easy reference in your IDE.</p>

<div class="source"><pre class="prettyprint"><code>    &lt;dependency&gt;
        &lt;groupId&gt;org.javimmutable&lt;/groupId&gt;
        &lt;artifactId&gt;collections&lt;/artifactId&gt;
        &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre></div></section><section>
<h2><a name="Project_Members:"></a>Project Members:</h2>
<ul>

<li><a class="externalLink" href="https://github.com/brianburton">Brian Burton</a> (admin)</li>
<li><a class="externalLink" href="https://github.com/anjbur">Angela Burton</a></li>
</ul></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>&#169;      2024
<a href="http://www.burton-computer.com">Burton Computer Corporation</a>
</p>
        </div>
      </div>
    </footer>
<script>
	if(anchors) {
	  anchors.add();
	}
</script>
  </body>
</html>
